Processos - Guia Essencial de Bolso

O que √© um Processo?

Um programa em execu√ß√£o, incluindo o c√≥digo do programa e toda a informa√ß√£o do seu estado (mem√≥ria, registradores, contador de programa, status de E/S) .

O ambiente onde um programa √© executado .

Estados de um Processo

Execu√ß√£o (Running): Sendo processado pela CPU .

Pronto (Ready): Aguardando na fila para ser executado .

Espera (Wait/Blocked): Aguardando por algum evento externo ou recurso .

üå≥ CRIA√á√ÉO DE PROCESSOS - √ÅRVORE DE PROCESSOS
Os processos pai criam processos filhos, que por sua vez podem criar outros processos, formando uma √°rvore de processos.

Compartilhamento de recursos (tr√™s abordagens):

Pai e filhos compartilham todos os recursos.

Filhos compartilham apenas um subconjunto dos recursos do pai.

Pai e filho n√£o compartilham recurso algum.

Execu√ß√£o:

Pai e filhos podem executar concorrentemente.

Ou o pai pode esperar at√© que os filhos terminem.

‚éê A CHAMADA FORK()
fork() √© a chamada de sistema no UNIX que cria um novo processo (filho) que √© uma duplicata do processo original (pai) .

O segmento de dados e c√≥digo do novo processo √© o mesmo do original.

c
#include <unistd.h>
pid_t fork(void);

Valor de retorno do fork():

Zero no processo filho.

O PID (Process ID) do processo filho no processo pai.

Use o valor de retorno para identificar onde o c√≥digo est√° sendo executado.

Exemplo Pr√°tico:

c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    if (fork() == 0) {
        printf("Eu sou o filho\n");
    } else {
        printf("Eu sou o pai\n");
    }
}
‚èπÔ∏è T√âRMINO DE PROCESSO - EXIT()
O processo executa sua instru√ß√£o final e pede ao SO para termin√°-lo com exit().

exit() realiza limpeza e retorna um status de t√©rmino.

Retornar um valor inteiro da fun√ß√£o main() √© equivalente a chamar exit() com o mesmo valor.

c
#include <stdlib.h>
int exit(int status);
O processo que termina notifica seu pai passando o exit status como argumento da fun√ß√£o exit().

O processo pai obt√©m esse status atrav√©s da fun√ß√£o wait() ou waitpid().

‚è≥ A FUN√á√ÉO WAIT()
wait() e waitpid() s√£o usadas pelo processo pai para tomar conhecimento do t√©rmino do filho e obter seu status .

c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
Comportamento do pai que chama wait()/waitpid():

Bloqueia se todos os filhos ainda estiverem em execu√ß√£o.

Retorna imediatamente com o estado de t√©rmino de um filho.

Retorna imediatamente com um erro.

Diferen√ßas principais :

wait() bloqueia at√© qualquer processo filho terminar.

waitpid() pode esperar por um processo filho espec√≠fico (identificado pelo pid).

waitpid() tem op√ß√µes para evitar o bloqueio se o filho especificado ainda n√£o terminou.

‚ò†Ô∏è PROCESSOS ZUMBIE
Ocorre quando um processo filho termina antes do pai chamar wait().

O kernel mant√©m uma pequena quantidade de informa√ß√µes do processo terminado para que o pai possa recuperar seu status mais tarde.

Um processo nesse estado √© chamado de Zombie ou <defunct>.

O que acontece se o pai terminar antes do filho?

O processo init (PID 1) se torna o novo pai do processo √≥rf√£o.

O init √© programado para chamar wait() quando um de seus filhos termina, coletando seu status e evitando zombies permanentes.

